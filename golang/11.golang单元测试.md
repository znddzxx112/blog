
- 必读文章
```
https://testerhome.com/topics/6374
https://medium.com/@rosaniline/unit-testing-gorm-with-go-sqlmock-in-go-93cbce1f6b5b
```

- 概要
```
1. 使用gotests命令，来完成表单形式、testify的suite形式，这二种方式都推荐，testify更推荐
2. http的单元测试库使用httpexcept
3. sql的单元测试库使用go-sqlmock
4. golang官方mock库使用gomock，除了http和mysql场景的测试之外使用
```

- 单元测试释义
```
不依赖外部，需要隔离外部依赖，对函数或者方法单独做测试。
外部包含：
1. 数据库
2. 一个app服务器（或者任何类型的服务器）
3. 文件/网络 I/O或者文件系统
4. 另外的应用
5. 控制台（System.out,system.err等等）
6. 日志
7. 大多数其他类
```

- 单元测试建议
```
1. 越重要的代码，越要写单元测试；
2. 代码做不到单元测试，多思考如何改进，而不是放弃；
3. 边写业务代码，边写单元测试，而不是完成整个新功能后再写；
4. 多思考如何改进、简化测试代码。
```

- 什么样的代码不能做单元测试？
```
函数，方法依赖其他类，但没有做好对其他类的隔离。比如：直接在方法中new一个依赖类出来，正确的方式，依赖类的接口通过方法的一个参数。
```

- 与系统测试比较
```
应用系统，数据库系统等多系统联合起来做测试。比如观测系统某个外部接口返回是否符合预期。
形如swagger工具：https://petstore.swagger.io/?_ga=2.181287012.2138967229.1548914867-1298560747.1548914867
```

- 表单驱动工具gotests
```
go get -u github.com/cweill/gotests/...
常用命令方法:
gotests -all -w texttoaudio_test.go texttoaudio.go // 为源码texttoaudio.go所有方法都生成测试
gotests -only "GetAudioPath" texttoaudio.go // 仅为GetAudioPath方法生成测试
```

- 官方mock工具gomock, 推荐使用 testify (https://github.com/stretchr/testify)
```
文档：https://godoc.org/github.com/golang/mock/gomock
常用命令：
mocgen -destination=textTask_mock.go texttoaudio/server/models TextTaskInf //为texttoaudio/server/models下的接口TextTaskInf 生成mock类
mock出stuct的InfoTextTaskKeyStatus方法
func TextTexttoaudio_GetAudioPath(t *testing.T) {
   mockCtrl := gomock.NewController(t)
   defer mockCtrl.Finish()

   textTaskStuct := mock_models.NewMockTextTaskInf(mockCtrl)
   textTaskStuct.EXPECT().InfoTextTaskKeyStatus(gomock.Any(),gomock.Any).Return(nil)
}
```

- 数据库mock库go-sqlmock
```
文档：https://godoc.org/gopkg.in/DATA-DOG/go-sqlmock.v1
mock出数据库
func TestTextWorker_CreateTextWorker(t *testing.T) {
  db, mock, _ := sqlmock.New()
  gormDb, _ := gorm.Open("mysql", db)
}
对select进行mock
func TestNewMtlProductWithId(t *testing.T) {
	db, mock, _ := sqlmock.New()
	gormDb, _ := gorm.Open("mysql", db)
	t.Run("success", func(t *testing.T) {
		columns := []string{"id", "name", "asset"}
		rows := sqlmock.NewRows(columns).AddRow(1, "mtl", "SIPC")
		mock.ExpectQuery("^SELECT (.+) FROM `mtl_product`").WithArgs(1).WillReturnRows(rows)
		got := NewMtlProductWithId(gormDb.Debug(), 1)

		if got.ID != 1 || got.Name != "mtl" || got.Asset != "SIPC" {
			t.Error("NewMtlProductWithId")
		}
		t.Log(got.ID, got.Name, got.Asset)
	})
}
func TestMtlLockPositionsList_ListMtlLockPositionsWithExpireTime(t *testing.T) {
	db, mock, _ := sqlmock.New()
	gormDb, _ := gorm.Open("mysql", db)
	t.Run("listSuccess", func(t *testing.T) {
		now := time.Now()
		yesterday := now.Add(-time.Hour * 24)
		columns := []string{"created_at","updated_at", "user_id", "product_id", "asset", "amount", "expire_time", "remark", "status"}
		rows := sqlmock.NewRows(columns).
			AddRow(yesterday, yesterday, 12345, 2, "SIPC", "100", now.Add(-time.Hour * 18), "remark1", 0).
			AddRow(yesterday, yesterday, 12346, 2, "SIPC", "100", now.Add(-time.Hour * 18), "remark2", 1)
		mock.ExpectQuery("^SELECT (.+) FROM `mtl_lock_positions`").WillReturnRows(rows)
		list, err := ListMtlLockPositionsWithExpireTime(gormDb.Debug(), 0, time.Now(), 10, 0)
		if err != nil {
			t.Error("ListMtlLockPositionsWithExpireTime, err", err)
		}
		t.Log(*list)
		if len(*list) != 1 {
			t.Error("ListMtlLockPositionsWithExpireTime")
		} else {
			t.Log(*list)
		}
	})
}
对update进行Mock
func TestMtlProduct_UpdateIncResAssetAmountWithId(t *testing.T) {
	db, mock, _ := sqlmock.New()
	gormDb, _ := gorm.Open("mysql", db)
	t.Run("UpdateSuccess", func(t *testing.T) {
		mock.ExpectBegin()
		mock.ExpectExec("UPDATE `mtl_product` SET `res_asset_amount`").WillReturnResult(sqlmock.NewResult(0, 2))
		mock.ExpectCommit()
		this := &MtlProduct{
			ID:1,
		}
		if err := this.UpdateIncResAssetAmountWithId(gormDb.Debug(), 100); err != nil {
			t.Error("UpdateIncResAssetAmountWithId")
		}
	})
	t.Run("UpdateFail", func(t *testing.T) {
		mock.ExpectBegin()
		mock.ExpectExec("UPDATE `mtl_product` SET `res_asset_amount`").WillReturnError(fmt.Errorf("%s", "db lost"))
		mock.ExpectCommit()
		this := &MtlProduct{
			ID:1,
		}
		if err := this.UpdateIncResAssetAmountWithId(gormDb.Debug(), 100); err == nil {
			t.Error("UpdateIncResAssetAmountWithId")
		}
	})
}
对insert进行mock
func TestMtlInvestLog_Create(t *testing.T) {
	db, mock, _ := sqlmock.New()
	gormDb, _ := gorm.Open("mysql", db)
	t.Run("createSuccess", func(t *testing.T) {
		mock.ExpectBegin()
		mock.ExpectExec("INSERT INTO `mtl_invest_log`").WillReturnResult(sqlmock.NewResult(10001, 0))
		mock.ExpectCommit()
		investLog := NewMtlInvestLog()
		investLog.UId = 109780
		investLog.ProductID = 2
		investLog.SiteID = 1
		investLog.DepositTime = time.Now()
		investLog.Asset = "SIPC"
		investLog.Amount = 100.01
		investLog.ExpectedYearEarning = 1.02
		investLog.PayoutAccount = 1
		investLog.PayoutType = 1
		investLog.UnlockTime = time.Now().Add(time.Hour * 24 * 360)
		investLog.NowEarning = 100
		investLog.Type = 1
		investLog.PayoutTime = time.Now().Add(time.Hour * 24)
		investLog.OrderNumber = "111"
		if err := investLog.Create(gormDb.Debug()); err != nil {
			t.Fatal("investLog.Create error", err)
		} else {
			t.Log(investLog.ID)
		}
	})
	t.Run("createFail", func(t *testing.T) {
		mock.ExpectBegin()
		mock.ExpectExec("INSERT INTO `mtl_invest_log`").WillReturnError(fmt.Errorf("%s", "db lost"))
		mock.ExpectCommit()
		investLog := NewMtlInvestLog()
		investLog.UId = 109780
		investLog.ProductID = 2
		investLog.SiteID = 1
		investLog.DepositTime = time.Now()
		investLog.Asset = "SIPC"
		investLog.Amount = 100.01
		investLog.ExpectedYearEarning = 1.02
		investLog.PayoutAccount = 1
		investLog.PayoutType = 1
		investLog.UnlockTime = time.Now().Add(time.Hour * 24 * 360)
		investLog.NowEarning = 100
		investLog.Type = 1
		investLog.PayoutTime = time.Now().Add(time.Hour * 24)
		investLog.OrderNumber = "111"
		if err := investLog.Create(gormDb.Debug()); err == nil {
			t.Fatal("investLog.Create error", err)
		} else {
			t.Log(investLog.ID)
		}
	})
}
```

- 推荐使用testify构建单元测试 (https://github.com/stretchr/testify)
```
1. 提供suite, 可以做初始化工作
2. 提供assert断言功能，可以少写许多断言类代码
3. 提供mock功能，前提是你写的代码能够被mock（依赖接口）
- 示例，suite/doc.go文件也提供了一个示例
type MtlLockPositionsListSuite struct {
	suite.Suite
	
	gormDb *gorm.DB
}
func (m *MtlLockPositionsListSuite)SetupTest()  {
	var err error
	db, mock, _ := sqlmock.New()
	m.gormDb, err = gorm.Open("mysql", db)
	if err != nil {
		m.Suite.Fail("gorm Open")
	}
	m.gormDb = m.gormDb.Debug()

	now := time.Now()
	yesterday := now.Add(-time.Hour * 24)
	columns := []string{"created_at","updated_at", "user_id", "product_id", "asset", "amount", "expire_time", "remark", "status"}
	rows := sqlmock.NewRows(columns).
		AddRow(yesterday, yesterday, 12345, 2, "SIPC", "100", now.Add(-time.Hour * 18), "remark1", 0).
		AddRow(yesterday, yesterday, 12346, 2, "SIPC", "100", now.Add(-time.Hour * 18), "remark2", 1)
	mock.ExpectQuery("^SELECT (.+) FROM `mtl_lock_positions`").WillReturnRows(rows)
}
func (m *MtlLockPositionsListSuite)TestListMtlLockPositionsWithExpireTime() {
	m.T().Run("listSuccess", func(t *testing.T) {
		list, err := ListMtlLockPositionsWithExpireTime(m.gormDb, 0, time.Now(), 10, 0)
		assert.Equal(m.T(), nil, err, "ListMtlLockPositionsWithExpireTime Error")
		assert.Equal(m.T(), 2, len(*list), "ListMtlLockPositionsWithExpireTime")
	})
}
func TestMtlLockPositionsListSuite(t *testing.T)  {
	suite.Run(t, new(MtlLockPositionsListSuite))
}
```

- 执行单元测试
```
go test -v . 	运行当前目录下所有测试文件的测试函数，必须当前路径下有测试文件，子文件夹里的测试文件不会检测到
go test -v ./… 	遍历运行当前目录下所有子文件夹内的测试函数
go test -v filename_test.go 	运行当前目录下某个测试文件里的所有测试函数

-v: 显示通过的详细测试信息，默认只显示错误信息以及通过的概要
```

- 参考文章
```
1. https://studygolang.com/articles/10722
2. https://juejin.im/post/58db5f9ab123db199f54e1e5
```
