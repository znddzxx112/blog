- 参考文章
```
https://www.cnblogs.com/onepixel/articles/7674659.html
```

- 时间复杂度说明
```
随着输入的增加，算法运行增速情况
```

- 概要
```
十大排序算法
七大查找算法
8种数据结构
22种设计模式
```

- 算法
```
1. 看算法的稳定性
2. 随着n的变化，总的操作次数变化情况。（时间复杂度）
3. 最好情况，最差情况，平均情况的时间复杂度是多少
```

- O(n^2)的排序算法
```
冒泡排序
比较前后二个数的大小，进行交换，从而使得大数下沉，小数冒泡。

选择排序
寻找数据中最大的数，放到最后面，从而完成排序。

插入排序
待比较的数，大于等于前面排序的数，往改数后面插入
```

- O(nlgn)的排序算法(重点，代码掌握)
```
快速排序
二路快速排序算法：
1. 分区，找到基准数，使得左侧小于基准数，右侧大于基准数
1.1 基线条件 head >= tail, 停止排序 
2. 左侧区域进行快速排序head:pivot，pivot+1:tail右侧区域进行快速排序

三路排序算法思路：
第一个元素做基准，二个哨兵分别从前往后，从后往前。
从后往前的哨兵发现小于基准的数停止前进等待交换，
从前往后的哨兵发现大于基准的数停止前进等待交换，二者交换。
当二个哨兵相遇，基准数与相遇数交换。
此时，基准数前的数都小于基准数，基准数后的数都大于基准数。
往复。

堆排序
构建一个最大堆（最大值是根节点），获取根节点，再调整构建最大堆，往复。

归并排序（二路归并，多路归并）
二个已经排序的子串，合并成一个排序的串


```

- O(n+k)的排序算法，借助空间，工业上不常用
```
计数排序
预先计算一个范围的有序数，遍历需要排序的数，进行计数。
根据预先的有序数，弹出需要排序的数，进行排序

桶排序
将数按照规则划分到一个桶（范围），然后按照桶的顺序排序，就完成。
体现分治的思想，解决计数消耗空间大问题。

基数排序
先按照个位排序，再按照十位排序，再按照百位排序，...(IBM公司创始人)
```

- 查找算法
```
二分查找
事先进行排序，然后依次二分查找。由于事先排序，时间复杂度就高，不采用

结合快排思想，查找
基准数左边小于基准数，右边大于基准数，确定区域再进行查找。

树表查找（重点）
构造二叉树进行查找。红黑树，B树, B+树。

哈希查找
```

- 数据结构
```
参考文章：https://blog.csdn.net/yeyazhishang/article/details/82353846
```

- 常见数据结构时间复杂度
```
参考文章：https://blog.csdn.net/weixin_40244153/article/details/94620126
```
![数据结构时间复杂度参考](https://github.com/znddzxx112/blog/blob/master/algorithm/20181015150829578.png)

```
1、数组
连续存储多个元素的结构，在内存中的分配也是连续的
频繁查询，对存储空间要求不大，很少增加和删除的情况。

2、栈
栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作

3、队列
队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素

4、链表
链表是物理存储单元上非连续的、非顺序的存储结构
单链表，双向链表，循环链表

5、树（重点）
二叉树是树的特殊一种，具有如下特点：

1、每个结点最多有两颗子树，结点的度最大为2。 
2、左子树和右子树是有顺序的，次序不能颠倒。 
3、即使某结点只有一个子树，也要区分左右子树。

关键词：
1. 搜索（左节点小于根节点，右节点大于根节点）
2. 平衡（树高是稳定的）

二叉树的价值点：用于查找

二叉树：二叉树中每个结点的孩子数只能是0、1或2个，并且每个孩子都有左右之分
满二叉树 ：所有的分支节点都具有左右节点
完全二叉树：（1）叶子结点只可能在层次最大的两层上出现；（2）对任一结点，若其右分支下的子孙的最大层次为l，则其左分支下的子孙的最大层次必为l或l+1。

参考文章：https://www.jianshu.com/p/e1c9e27ceb2b

二叉树遍历方式：前序遍历，中序遍历，后续遍历
前、中、后序遍历是针对中间（父亲）节点来说的

广度优先遍历：前序遍历 + 队列的结构（保存访问过的元素）
深度优先遍历：中序遍历 + 栈的结构（保存访问过的元素）

平衡二叉树（AVL树）：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1
非平衡二叉树转换平衡二叉树的方式：通过旋转变化选中一个节点重新作为根节点

二叉搜索树：左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。
红黑树：平衡二叉搜索树，解决二叉搜索树树高爆涨，时间复杂度变为0（N）
2-3树（B树）：也是平衡多路搜索树,多个节点，通过增加节点数目比红黑树具有更低的树高
B+树：也是平衡多路搜索树,多个节点，比B树更多的节点，更低的树高。mysql的数据库索引结构用的就是B+树。

2-3树：
2节点：有2个子节点或者0个，节点存储1个元素
3节点：有3个子节点或者0个，节点存储2个元素
2-3-4树
2节点：有2个子节点或者0个，节点存储1个元素
3节点：有3个子节点或者0个，节点存储2个元素
4节点：

霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。解决霍夫曼编码。

参考文章：https://blog.csdn.net/Double2hao/article/details/53286038

B树（多路搜索树）：每一个节点的子节点可以多于二个子节点，并且节点可以存储多个元素。

6、散列表
这里的对应关系 f 成为散列函数，又称为哈希 (hash函数)，
而散列表就是把Key通过一个固定的算法函数既所谓的哈希函数转换成一个整型数字，
然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，
将value存储在以该数字为下标的数组空间里

7、堆（重点）
完全二叉树，是有序的，所以可以用来做排序

8、图
图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，
分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构

```

- 红黑树
```
参考文章：https://www.cnblogs.com/ailumiyana/p/10963658.html
golang red-black tree:https://github.com/sakeven/RbTree
红黑树结构的优势：插入，查询，删除，更新的时间复杂度是logN, 平均情况和最坏情况也是logN。
可用于是一种优秀的查询算法

相比较于二叉树，左节点小于跟节点，右节点大于根节点。存在最差情况的时间复杂度为N

红黑树性质：
1、所有节点的颜色不是红色就是黑色。
2、根节点是黑色。
3、每个叶子节点都是黑色的空节点(nil)。
4、每个红色节点的两个子节点都是黑色。(从每个叶子到根节点的所有路径上不能有两个连续的红色节点)
5、从任一节点到其叶子节点的所有路径上都包含相同数目的黑节点。

1~4点比较好理解，第5点说明这个树是平衡性质的，意味着搜索时，从根节点到叶子节点的查找次数都差不多

为了维持红黑树性质，需要这三个操作：1. 节点变色 2. 左旋转 3.右旋转。旋转会涉及三个节点，2个节点进行旋转

红黑树的插入有以下5钟情况：
情形1：空树
直接插入，直接作为根节点，同时由于性质1的约束，通过变色op变为黑色即可。

情形2：插入节点父节为黑色
不违反任何性质，无需做任何修改。

情形3 插入节点的父节点为红色，父节点为父父节点的左孩子，父父节点的右孩子为黑色，插入节点为左孩子(或者父节点为父父节点的右孩子，父父节点的左孩子为黑色，插入节点为右孩子)。
这是一种插入节点和父节点在一个方向上的情况(例如父节点为左孩子，插入节点也为左孩子)和情形5相反
父节点 及 父父节点变色，再进行左/右旋转， 具体左还是右看你插入的节点的父节点是左子树还是右子树，图例为左子树。
此处 : 变色 - > 右旋转

情形4 插入节点父节点为红色，父父节点的左/右孩子为红色
先将父节点和父父节点右孩子变黑，父父节点变红，然后将父节点当做新插入的红色节点一样递归向上进行平衡红黑树性质操作。 若父节点为根节点直接变父节点为黑色即可.
此处 : 变色 -> 变色

情形5 插入节点的父节点为红色，父节点为父父节点的左孩子，父父节点的右孩子为黑色，插入节点为右孩子(或者父节点为父父节点的右孩子，父父节点的左孩子为黑色，插入节点为左孩子)。
和情形3类比是一种反向情况，这种情况进行两次旋转，
先左/右旋转，旋转后变成了情形3，接着按情形3变换即可。
此处 ：左旋转 -> [变成情况3]然后变色 -> 右旋转

思考红黑树的缺陷？
红黑树是平衡搜索树，但是树高容易长高，要从根节点读取到叶子节点需要树高的i/o读取
所以平衡搜索2-3树即B树，平衡搜索多节点机B+树。解决树高的问题。一般的B+树只要2次i/o（根节点常驻内存）
```
- b tree
```
https://blog.csdn.net/Fmuma/article/details/80287924
B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是我们常见的二叉搜索树。

一颗m阶的B树定义如下：

1）每个结点最多有m-1个关键字。

2）根结点最少可以只有1个关键字。

3）非根结点至少有Math.ceil(m/2)-1个关键字。

4）每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。

B树的插入操作
1）根据要插入的key的值，找到叶子结点并插入。
2）判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。
3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中
这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。

B树的删除操作
1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步
2）该结点key个数大于等于Math.ceil(m/2)-1，结束删除操作，否则执行第3步。
3）如果兄弟结点key个数大于Math.ceil(m/2)-1，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。
否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。
有些结点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟结点进行操作即可。
```
![b树欣赏](https://github.com/znddzxx112/blog/blob/master/algorithm/b.png)

- b+tree
```
B+树的定义
1）B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。
2）B+树与B树最大的不同是内部结点不保存数据，只用于索引，所有数据（或者说记录）都保存在叶子结点中。
3） m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。
4）内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。
5）每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。

B+树的删除操作
1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。
2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。
3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。
4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步
5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步
6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。
```
![b+树欣赏](https://github.com/znddzxx112/blog/blob/master/algorithm/b+.png)
