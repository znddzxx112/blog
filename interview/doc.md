

[TOC]



### 自我介绍

```
1. 项目介绍，承担什么角色
2. 业务线上负责什么，技术线上负责什么
```



### 汇编语言&计算机组成

#### 什么是机器语言？

> 机器指令的集合，机器可以直接执行的命令

#### 什么是汇编语言？

> 机器指令便于记忆的书写格式

#### 机器如何读懂汇编指令?

> 汇编指令通过编译器转化成为机器码

#### 什么是寄存器？

> cpu中存储数据的器件。总共由14个寄存器。寄存器是32位，则是32位。
>
> AX、BX、CX、DX是通用寄存器，存放数据
>
> CS、IP是段寄存器。CS指明代码段地址，IP指明代码段偏移地址。CS、IP指向的内存地址数据会按照机器指令进行解析
>
> DS、ES是段寄存器。DS指明数据段地址，ES指明数据段的偏移地址。
>
> SS、SP是段寄存器。SS指明栈顶段地址，SP指明偏移地址。SS:SP指明栈顶元素
>
> si di和bx功能相近的寄存器 [bx], [si], [di]
>
> 标志寄存器PSW
>
> ​		ZF标志：判断执行结果是否为0
>
> ​		PF标志：奇偶标志
>
> ​		SF标志：相关指令执行后，结果是否为负。负数则为1，代表有符号数进行运算
>
> ​		CF标志：无符号数运算，记录最高位进位
>
> ​        OF标志：溢出标志位  页码：218
>
> ​        DF标志：控制si,di的递增和递减

##### 问题：标志寄存器PSW能做哪些事情？





##### 问题：栈的作用？

> 用桟暂存以后需要恢复的寄存器中的内容。出桟的顺序要和入栈的顺序相反





#### 汇编指令

> 传输指令
>
> ​	push 、 pop：实质是内存的传送指令，寄存器与内存之间传送数据
>
> pushf、popf: 标志寄存器传入栈中
>
> in、out 读写端口指令
>
> 转移指令
>
> ​	jmp 同时修改CS，IP的值。
>
> jmp short 标号：段内-128-127 ip的修改范围
>
> jmp far ptr 标号：远转移
>
> jcxz: 如果 cx寄存器为0 ，则跳转
>
> ret:把IP寄存器从到栈中取出
>
> retf:把IP和CS从寄存器中取出
>
> call: 把IP和cs寄存器中的值放入栈中
>
> je,jne  结合cmp结果，进行转移
>
> loop 执行cx寄存器自减，cx不为0 跳转到loop指定的标号
>
> 运算指令
>
> ​	add, sub
>
> ​    div，mul
>
> adc：带进位加法指令
>
> sbb:带借位的减法
>
> cmp：比较指令，相当于做减法，结果保存在状态PSW标志器中



#### 计算机中的存储单元？

> 8个位 = 1个字节

#### cpu对存储器的读写过程？

> cpu通过数据线，地址线，控制线。
>
> 控制线：控制读或者写
>
> 地址线：8位寄存器通过地址加法器可以生成20位的地址，控制4GB的内存空间。分成段地址+偏移地址。物理地址=段地址*16+偏移地址
>
> 数据线：一次读写从内存读入数据
>
> 读取过程：cpu通过总线从地址线指明的地址读取数据到寄存器
>
> 写过程：cpu通过总线将寄存器数据写到地址上
>
> 主板，接口卡都可以当作内存对待

cpu可以直接读写的3个地方的数据

> 1、内部寄存器
>
> 2、内存单元
>
> 3、端口

#### 编程本质

> 程序员通过改变寄存器的内容实现对cpu的控制
>
> 程序大部分是进行数据处理，处理数据之前要搞清楚数据放在哪里
>
> 数据可以放在cpu内部，内存，端口

#### 程序写出到执行过程

> 第1步：编写程序代码
>
> 第2步：代码进行编译链接。编译是将代码生成目标文件，再用连接程序ar对目标文件进行链接，产生可执行文件
>
> 可执行文件包含1. 目标文件，即机器码
>
> 2. 描述信息。程序大小和需要占用的内存空间
>
> 第3步：操作系统将程序调入内存
>
> 其中可执行文件中是有代码段，数据段和栈组成的

#### 连接的作用？

> 如果程序中调用了某一个库文件的子程序，就需要在连接的时候，将库文件和目标文件连接到一起，生成可执行文件。
>
> 同时加上描述信息。

#### 问题：谁将可执行文件载入内存并使它运行？

> 一个正在运行的程序（操作系统）将它载入内存，并将CPU控制权交给它（CS：IP指定），运行完之后，将控制权交还给操作系统

#### 问题：如何函数调用中参数和结果传递问题？

> 调用者将参数放入栈中，Call 子程序，子程序从栈获取参数，将执行结果也放入栈中，执行ret返回调用者



### 中断

#### 问题：什么是中断？

> 任何一个通用CPU，可以在执行完当前正在执行指令之后，检测从CPU外部或者内部的特殊信息，并对这种特殊信息做处理。这种特殊信息为中断信息。
>
> 本质：cpu不再继续执行指令，转而去处理这个特殊信息

#### 问题：内中断有哪几种？

> 除法错误
>
> 单步执行-  程序调试
>
> 执行info指令
>
> 执行int指令 - 汇编中手动触发中断

#### 问题：中断过程是怎么样的？

> CPU执行一步指令之后， 收到中断信息、其中包含中断类型码。开始处理中断信息，通过中断类型码在中断向量表找到中断处理程序入口CS和IP值，开始执行中断处理程序，执行完后iret指令，返回到CPU依照原先继续执行
>
> 准备处理中断，会将当前寄存器的值放入栈中
>
> 中断处理程序 就是一个子程序，用来响应中断信息

#### 问题：单步执行中断过程是怎么样的？

> CPU执行指令之后，检查状态寄存器ZF标志位，值为1，则执行1号中断处理程序（等待用户输入调试指令）

#### 问题：如何产生外中断？

> 通过int指令引发中断
>
> int 0 : 引发0号中断
>
> 相关芯片向CPU发送中断信息
>
> 外设输入到达，会产生9号中断，cpu检测IF标志位，不为0，则响应中断，将输入放置缓存区中

#### 问题：cpu如何不响应外中断？

> 将标志寄存器IF位为0

#### 问题：BIOS和操作系统中断程序的安装过程

> 1、开机后，CPU加电，从ffffH：0内存单元开始处理，这里是跳转指令。跳到BIOS硬件系统检测和初始化程序
>
> 2、BIOS初始化程序会将BIOS中断程序登记到中断向量表
>
> 3、随后执行int 19h中断，进入操作系统引导。控制权交给操作系统。
>
> 4、操作系统也会将自身中断程序登记到中断向量表
>
> 系统中断程序 = 系统调用程序 = 用汇编程序书写程序才可直接使用、c，go语言有一一对应的库函数实现
>
> 调用系统调用时，已经进入操作系统的系统态

#### 问题：磁盘读写的过程是怎么样？

> 软盘分上下二面、每面有80个磁道，每个磁道有18个扇区，每个扇区512个字节
>
> 则 软盘大小为2面 *  80磁道  *  18个扇区 * 512字节 等于 1.44MB左右
>
> 首先：要确定从读取位置
>
> 驱动器号 0：软驱A 1：软驱B 80H：硬盘C 81H硬盘D
>
> 磁头号：哪个面
>
> 扇区号、磁道号、读取扇区数
>
> 内存单元
>
> 读写标志
>
> 将以上数据通过调用int 13h中断程序告诉磁盘控制器，磁盘控制器将数据读取或者写入内存单元

#### 问题：逻辑扇区号是什么？

> 将上述物理扇区进行编号
>
> 逻辑扇区号 = （面号*80 + 磁道号* ） *  18 + 扇区号 - 1
>
> 面号 = int (逻辑扇区号 / 1440)
>
> 磁道号= int( rem(逻辑扇区号 / 1440) / 18)
>
> 扇区号 = rem( rem(逻辑扇区号 / 1440) / 18) + 1 
>
> 逻辑扇区号 + 内存单元 + 读写标志，再调用int 13h 中断程序，磁盘控制器将数据读取或者写入内存单元



### 计算机操作系统

#### 问题：操作系统的作用？

> 1、作为用户与计算机硬件系统之间的接口
>
> ​		命令行，系统调用（系统中断程序）- golang的标准库会去调用
>
> 2、作为计算机系统资源的管理者
>
> ​		处理机器管理
>
> ​					进程控制、进程同步（多个进程运行进行协调）、进程通信、
>
> ​					调度（作业调度、进程调度）
>
> ​		存储器管理（内存分配与回收）
>
> ​					内存分配：运行时程序，内存动态增长
>
> ​					内存保护：硬件实现防止越界、软件配合
>
> ​					地址映射
>
> ​					内存扩充：请求调入、置换功能
>
> ​		IO设备管理
>
> ​					缓存管理
>
> ​					文件管理、目录管理
>
> ​		信息（数据和程序）
>
> ​       共享资源的使用，避免冲突
>
> 3、实现对计算机资源的抽象

#### 问题：操作系统的基本特性？

> 1、 并行与并发
>
>    并行： 同一个时刻多个事件同一时刻发生
>
> ​    并发：在一段时间内发生，先后顺序不确定
>
> 2、引入进程、线程。资源分配单位，cpu调度单位
>
> 3、 资源共享
>
> 4、虚拟技术
>
> 5、异步性

#### 问题：什么是操作系统微内核？

> 1、足够小、提供核心功能
>
> 2、基于客户/服务器模式
>
> 3、机制与策略分离
>
> 4、采用面向对象技术：抽象、隐蔽。封装和继承。正确性、可靠性、易修改、易扩展

### 进程管理

#### 问题：作业调度流程是怎么样的？

> 从磁盘中程序调入至内存中，分配PCB(管理信息)，此时进程处于就绪状态
>
> 进程是程序的一次执行

#### 问题：进程有哪几个部分组成？

> PCB 进程控制块、代码段、数据段、栈
>
> PCB：管理信息、进程标识、处理机状态（寄存器信息）、现行运行状态、优先级、程序段和数据段开始地方、所需资源清单

#### 问题：进程有哪些状态？每种状态产生原因？

> 就绪  -  静止就绪
>
> 执行
>
> 阻塞 - 静止阻塞
>
> 就绪状态：分配PCB，但未分配主存信息

#### 问题：进程调度流程是在怎么样的？

> 挂起、激活
>
> 阻塞、唤醒
>
> 以上4个原子操作，让进程在几个状态之间切换

#### 问题：进程同步有那几种情况？过程是怎样的？

> 同步：让并发的进程协调起来
>
> 1、对于临界资源访问，使用互斥量 - 锁方式
>
> 2、一般性的进程同步，使用信号量。golang中使用wait，done实现协程同步

#### 问题：生产-消费者问题 - 同步问题是怎么样的？解决方案是什么？

> golang:
>
> 如何避免重复关闭管道？从已关闭的管道中写数据？
>
> sync.Once
>
> 如何停止从一个管道中读取数据？

#### 问题：哲学家进餐问题  是怎么样的？解决方案是什么

#### 问题：读者-写者问题是怎么样的？解决方案是什么？

> 读写锁

#### 问题：进程通信有哪几种方式？



#### 问题：线程是怎么样的？

> 需要内核支持线程。cpu的时间片轮转线程。一个进程至少一个线程。
>
> 线程有线程控制块，记录寄存器信息
>
> golang用户级线程，能获得更多的cpu执行时间。

#### 问题：作业调度调度算法有哪些？

> 程序首先增加作业控制块，通过调度算法，从外存调入内存
>
> 作业调度算法：
>
> 先来先服务算法、短作业优先、作业优先级、响应比高者优先算法

#### 问题：进程调度方式有哪些？

> 非抢占式：线程分配给它，不管它运行多长时间、都让他一直运行下去
>
> ​		除非 1、执行完毕 2、发生IO请求 3、进程通信或同步执行某种原语
>
> ​		golang协程属于这种凡是
>
> 抢占式：基于某种原则来执行，更加公平。
>
> ​       比如：优先权、短作业、时间片

#### 问题：调度实现方式？调度模型是怎么样？使用什么样的数据结构？

#### 问题：产生死锁的原因？产生死锁的必要条件？

> 1、竞争资源
>
> 2、进程间推进顺序非法。请求和释放资源顺序不当。
>
> 必要条件：
>
> 1、互斥条件
>
> 2、请求和保持条件
>
> 3、不剥夺条件
>
> 4、环路等待条件

#### 问题：如何避免死锁？

> 使用银行家算法避免

#### 问题：如何检测死锁？

> 系统要记录资源请求和分配信息-资源分配图
>
> 提供算法检测死锁
>

#### 问题：如何解除死锁？

> 方法1、剥夺资源。从其他进程剥脱足够资源给死锁进程，解除死锁
>
> 方法2、撤销进程。

#### 问题：程序变成进程的过程？

> 程序通过编译，链接link，汇编
>
> 编译：是将本代码编译成汇编代码
>
> 链接：本代码使用了共享的代码段，根据是否链接进来，分为静态链接和动态链接
>
> 汇编：把汇编代码转化为二进制代码

#### 问题：程序装入过程？

> 采用动态运行装入方式
>
> 程序中包含逻辑地址，成为进程时，在1GB内核空间中分配pcb(task结构体)和页表，每次涉及地址操作时，会通过页表找到真正的物理地址。
>
> 程序的代码段是在低地址，BSS段（未初始化全局变量、static），堆段，栈段。这些放在3G的用户空间
>
> PCB和页表放在内核空间，高地址1GB中。内核空间也叫低端内存，用户空间叫高端内存。

#### 问题：什么是快表？

> cpu通过mmu内存管理单元将逻辑地址转化为物理地址
>
> 转化使用了内核空间的页表，页表还是内存中，内存读取速度是比较慢的。
>
> 快表将页表信息存储于高速缓存中

#### 问题：什么是缺页中断？什么是页面置换？页面置换算法有哪些？

> 开始运行时，不会把所有的程序中页都载入内存，只有用到时发现内存没有，发生缺页中断，从外存中取到内存
>
> 内存比较满了，把内存页放到swap分区中就是页面置换过程。
>
> 先进先出、最久未使用置换算法

#### 问题：如何访问硬盘数据的过程是怎么样的？

> 会设立缓冲区
>
> 如果是写入硬盘，cpu先把内存数据放到缓存区内存中，命令DMA从缓冲区数据写入硬盘
>
> 如果是从硬盘读取，DMA先将数据写入缓冲区，cpu再从缓冲区获取数据。

#### 问题：硬盘分区的作用？

> 每个分区变成了独立的逻辑磁盘，从0开始
>
> 每个分区起始扇区和大小都记录在磁盘0扇区的主引导记录。
>
> 可以从硬盘引导系统

#### 问题：硬盘格式化的作用？

> 设置引导块
>
> 设置根目录、空文件系统

### linux内核设计与实现

#### 问题：程序的数据段放了哪些数据？

> 全局变量、打开文件
>
> 比如golang mheap结构体

#### 问题：进程在内核中是如何管理？

> 进程和线程的结构体是task_struct, 每个task_struct组成了双向循环链表
>
> task_stuct包含进程状态、pid，ppid
>
> 线程有内核栈和用户空间的栈。当触发系统调用时，就用到了内核栈。如果是用户态的程序调用，使用用户栈。

#### 问题：什么是程序虚拟内存地址？

> 每个程序都是从0地址开始编码，分成代码段，数据段，堆，栈
>
> 虚拟内存地址转化成物理地址，通过mmu内存管理单元和页表

#### 问题：如何查看程序各个段的内存映射？

```
cat /proc/进程/status
cat /proc/进程id/maps
```



### CCNA

#### 问题：什么冲突域？

> 在同一个冲突域的设备，其中一台发送帧时，其他设备必须监听它
>

#### 问题：什么是广播域？

> 是指一个网段中所有设备组成的集合、其中一台向广播地址发送帧时，这些设备侦听该网段中的广播。
>
> 路由器的一个端口内是一个广播域，vlan划分的子网是一个广播域

#### 问题：什么是广播？

> 一台主机发送网络广播时，网络中所有设备必须读取和处理这个广播
>
> 是硬件广播
>
> 广播是帧，帧的目标mac为：ff:ff:ff:ff
>
> 路由器的接口收到广播后会将广播丢弃，起到分割广播域的作用

#### 问题：什么是组播？

> 将消息或数据发给IP组播地址，路由器将分组的副本从每个接口转发出去，给订阅了该组播的主机。
>
> 不同于广播，路由器不转发广播

#### 问题：什么是网关？

> 路由器接口的ip或者vlan虚拟子网中等同路由器接口的ip
>
> 网关不同于广播地址

#### 问题：路由器的作用？

> 路由器是三层设备，对IP分组进行过滤和交换
>
> 1、分组交换
>
> 2、分组过滤
>
> 3、网络间通信
>
> 4、路径选择，ip路由

#### 问题：交换机的作用？

> 交换机是转发或过滤帧，帧主要字段是mac地址
>
> 交换机的每个端口都是一个独立冲突域
>
> 交换机是多端口的网桥
>
> 网桥是从自身设备一个端口进来的数据，使其从另一个端口出去

#### 问题：OSI模型各个层的作用

> 应用层：展示给用户
>
> 表示层：对数据进行编码和转换功能
>
> 会话层：建立、管理和终止会话
>
> 传输层：将数据分段并重组为数据流
>
> 网络层：确定最佳的数据传输路径，传输分组。确定网络位置，建立路由表。还要获悉目标主机的mac地址，通过arp协议。
>
> 数据链路层：使用硬件mac地址将帧传输到正确设备。确定设备的位置，建立mac地址过滤表
>
> 物理层：发送和接受比特

#### 问题：传输层保证TCP是可靠的？

> 流量控制
>
> ​	1.握手阶段，双方协商连接参数， 窗口大小=发送方最多一次发送n个数据段
>
> 确认与重传机制
>
> ​	保证数据不会漏发

#### 问题：半双工与全双工的区别

> 半双工使用一条导线，全双工使用二条导线
>
> 半双工好比单车道公路，一个时刻只能处于发送/接收
>
> 全双工好比多车道公路，一个时刻可以通知发送和接受
>
>   集线器用的是半双工，其他设备是全双工

####   问题：以太帧Ethernet_II帧有哪些字段？

![6-191106130541362](./6-191106130541362.gif)

![20190613214942454_](.\20190613214942454_.png)

| 字段           | 含义                                                         |
| -------------- | ------------------------------------------------------------ |
| 前同步码       | 用来使接收端的适配器在接收 MAC 帧时能够迅速调整时钟频率，使它和发送端的频率相同。前同步码为 7 个字节，1 和 0 交替。 |
| 帧开始定界符   | 帧的起始符，为 1 个字节。前 6 位 1 和 0 交替，最后的两个连续的 1 表示告诉接收端适配器：“帧信息要来了，准备接收”。 |
| 目的地址       | 接收帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。作用是当网卡接收到一个数据帧时，首先会检查该帧的目的地址，是否与当前适配器的物理地址相同，如果相同，就会进一步处理；如果不同，则直接丢弃。 |
| 源地址         | 发送帧的网络适配器的物理地址（MAC 地址），为 6 个字节（48 比特）。 |
| 类型           | 上层协议的类型。由于上层协议众多，所以在处理数据的时候必须设置该字段，标识数据交付哪个协议处理。例如，字段为 0x0800 时，表示将数据交付给 IP 协议。 |
| 数据           | 也称为效载荷，表示交付给上层的数据。以太网帧数据长度最小为 46 字节，最大为 1500 字节。如果不足 46 字节时，会填充到最小长度。最大值也叫最大传输单元（MTU）。  在 Linux 中，使用 ifconfig 命令可以查看该值，通常为 1500。 |
| 帧检验序列 FCS | 检测该帧是否出现差错，占 4 个字节（32 比特）。发送方计算帧的循环冗余码校验（CRC）值，把这个值写到帧里。接收方计算机重新计算 CRC，与 FCS 字段的值进行比较。如果两个值不相同，则表示传输过程中发生了数据丢失或改变。这时，就需要重新传输这一帧。 |

#### 问题：如何构造帧、ip分组、数据段？

> 通过golang的github.com/google/gopacket

#### 问题：什么情况下用直通电缆、交叉电缆

> 主机或者路由器与交换机或集线器相连，用直通电缆
>
> 其他情况用交叉电缆

#### 问题：OSI模型的数据封装流程？

![1209537-20180316141535710-1359862908](.\1209537-20180316141535710-1359862908.png)

> 网络层负责获悉目标硬件地址，指明分组发送到本地网络主机或者本地网关，可通过arp协议获取到目标地址的mac地址
>
> 网络层将分组传给数据链路层，一同传递的还有本地网络主机或者网关硬件地址

#### 问题：什么是TLS？

> tls 传输层安全 前身 ssl安全套接字层

#### 问题：什么是DHCP？

> 实现一个主机加入一个网络时，自动获得一个 IP 地址的功能，流程如下
>
> 1. DHCP 客户端广播一个 **DHCP 发现消息**，寻找本网络中的 DHCP 服务器。
>
> 　　2. DHCP 服务器收到消息，并广播一个 **DHCP 提供消息**，其中包括一个预分配个 DHCP 客户端的 IP 地址。
>
> 　　3. DHCP 客户端收到提供消息，如果接受该 IP 地址，就广播一个 **DHCP 请求消息**。
>
> 　　4. DHCP 服务器广播 **DHCP 确认消息**，告知其他主机，我正式把一个 IP 地址分配给新来的客户机。

#### 问题：tcp数据段格式？

![OIP](.\OIP.jpg)

> 数据偏移：整个TCP首部的长度，20字节的固定首部+选项（长度可变）

> 建立虚电路，可靠传输
>
> 虚电路：三次握手 + 4次挥手，建立连接
>
> 可靠传输：流量控制 + 确认和重传机制
>
> 虚电路：1个字节的标志位
>
> 流量控制：窗口大小
>
> 确认和重传机制：序号和确认号

#### 问题：udp数据段格式？

![OIP_1](.\OIP_1.jpg)

> UDP长度：整个UDP首部字段，包含8字节+UDP数据总长度

#### 问题：udp和tcp的比较，如何使udp成为tcp？

> udp在传输信息，占用网络资源更少
>
> 只要在应用层实现 虚电路建立，流量控制，确认与重传机制，便可以使udp变成tcp

#### 问题：ip数据报格式？

> 如果IP分组太大无法放入一个帧中，ip会将一个ip分组进行分片操作
>
> 协议区分不同的数据报，tcp或者udp
>
> 生存时间：分组到达目的地前经历跳数

![de4031fe3c32ebffc7c260f87ff8d796_r](.\de4031fe3c32ebffc7c260f87ff8d796_r.png)

> 协议：
>
> ICMP  1
>
> tcp 3
>
> igrp 9
>
> udp 17
>
> EIGRP 88
>
> OSPF  89
>
> IPv6  41
>
> L2TP 115

#### 问题：ARP协议过程？

> 发送3层广播，随后发送帧广播，目标主机监听广播，回复ip
>
> 是由网络层发出arp协议

![arp](.\arp.jpg)

#### 问题：有类路由选择？

> 规定：
>
> 第一个字节范围
>
> A类地址:0xxxxxxx => 0000 0000 ~ 0111 1111 0~127.开头
>
> B类地址:10xx xxxx => 1000  0000 ~ 1011 1111 128~191 开头
>
> C类地址:110x xxxx => 1100 0000 ~ 1101 1111 192~223 开头



#### 问题：什么是无类路由选择？

> 英文：CIDR  : 192.168.19.24/29
>
> 每个子网必须要第一个子网和最后一个广播地址
>
> 目的是：使用逻辑网络编制方案
>
> A类地址子网划分：比如 10.1.3.65/23
>
> B类地址子网划分：比如 172.16.0.0/20
>
> C类地址子网划分：比如 192.168.19.24/29
>
> /29 是确定了子网掩码

#### 问题：子网掩码作用？

> 划分出网络部分和子网部分，提高地址空间使用效率
>
> 一旦确定子网掩码就确定了以下几个部分
>
> 1、将创建多少个子网？/192   方式1：256/（256-192）= 4个子网 方式2 2^2 = 4个
>
> 2、每个子网包含多少台主机？ 256-192 = 64个
>
> 3、由哪些合法的子网？每隔64台，0、64、128 ...
>
> 4、子网的广播地址是？子网地址？每个子网0、64、128 ... 子网最后一个地址是广播地址
>
> 5、子网可包含的主机地址？

#### 问题：无类组网

> 路由器要支持无类路由，路由选择协议有RIPv2、EIGRP、OSPF。支持路由器每个接口上使用不同子网掩码。
>
> 邻接路由器之间发送路由更新，IP层网络层协议类型有OSPF和EIGRP，就是这类信息。
>
> ccna 129页
>
> 邻接路由器通告的汇总地址和子网掩码，方法：确定块大小，汇总地址为块中第一个地址，子网掩码为块大小对应的子网掩码
>
> 汇总地址子网块中第一个子网地址
>
> 邻接路由器之间使用/30的子网掩码即可

### 路由器

#### 问题：如何进入路由器用户EXEC模式、特权模式、全局配置模式？

```
Router>enable
Router#config
Configuring from terminal, memory, or network [terminal]? terminal
?Must be "terminal", "memory" or "network"
Router#disable
```

#### 问题：如何配置接口、子接口、路由选择协议？

```
Router# config t
Enter configuration commands, one per line.  End with CNTL/Z.
Router(config)#interface fastEthernet 0/0
Router(config-if)#exit
Router(config)#interface fastEthernet 0/0.1
Router(config-subif)# exit
Router(config)# router ospf
```

#### 问题：如何配置快速以太口，串口并启用、配置ip？

```
Router(config)#interface fastEthernet 0/1 插槽1
Router(config-if)#no shutdown
Router(config-if)#do show int f0/1
Router(config)#interface s0/1/0 插槽1
Router(config-if)#ip address 192.168.3.254 255.255.255.0
Router(config-if)#do show int f0/1
```





### linux系统排查

```
源代码部分

program部分可用的排查工具:
gdb 调试工具
ldd 查看程序依赖库
lsof 一切皆文件
nm 目标文件格式分析
readelf elf文件格式分析
objdump 二进制文件分析
size 查看程序内存映像大小

process部分可用的排查工具：
对process : ps 进程查看器
对栈：pstack 跟踪进程栈
对进程间通信: ipcs 查询进程间通信

linux系统系统排查:
sar 找出系统瓶颈利器
cpu top
io iostat 监视io
memory vmstat 监视内存使用情况 free 查询可用内存
对系统调用: strace 跟踪进程中的系统调用



ps 进程查看器

```

- nginx
```
nginx 主要就是三大模块 http(7层) stream（4层 tcp层） mail（邮件模块）
比如：http和stream 都有pass_proxy指令，但在不同模块。
能做tcp代理的有nignx, haproxy ,twempory

http 模块下的指令
1. location指令，=,^~,~,~*,顺序
2. rewrite指令,url重写, regex,replace last|break|redirect|
3. 配置php-fpm关键指令, fastcgi_param SCRIPT_FILENAME $document_root/foo/index.php
4. proxy_pass与upstream
5. 理解listen 127.0.0.1:80 与 listen 80 区别
```

- mysql
```
1. sql语句，创建用户并授于增删改查所有库表的权限
1.1 修改密码update user ''@'' set password = password('')
2. sql语句，创建唯一的联合索引
3. 索引引擎区别，btree索引与hash索引的区别
innodb和myisam都是用b+tree索引，不同的是myisam的b+tree不带数据需要回表，
b+tree索引带数据不需要回标，聚餐索引。innodb支持行锁，有更高的并发。
innodb的辅助索引记录的是主键id，查本身的索引b+tree得到主键id，再去主键索引b+tree树获得数据。
联合索引的存储结构参考https://blog.csdn.net/weixin_30531261/article/details/79329722
3.1 b+树非叶子节点保留指针、索引值，叶子节点保留数据、整行数据、数据块地址+行号

Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点.

innodb 是mysql5.5以后默认存储引擎，使用场景
1).需要支持事务的业务(例如转账,付款)
2).行级锁定对于高并发有很好的适应能力,但是需要保证查询是通过索引完成.
	因为有行锁，对写多读少场景更加友好。
3).数据读写及更新都比较频繁的场景,如:BBS,SNS,微博,微信等.
4).数据一致性要求很高的业务.如:转账,充值等.
5).硬件设备内存较大,可以很好利用InnoDB较好的缓存能力来提高内存利用率,尽可能减少磁盘IO的开销.

4. 索引最左原则
4.1 or是不走索引，会破坏索引
4.2 like 不以%开头的话，会使用索引
大表分页的limit问题
使用子查询或者where id
行锁颗粒小，但是维护成本高，大量写入时，选用表锁
5. 什么样的列适合做为索引列，高区分度
6. sql语句，如何设置慢日志,访问日志
	#开启慢查询 slow_query_log值为1或on表示开启，为0或off为关闭
	slow_query_log=on 
	#设置慢查询日志放在哪里
	slow_query_log_file=mysql-slow 
	#设置sql执行时间多长为慢查询
	long_query_time=2
	# 设置
	SET GLOBAL slow_query_log = ON
	SHOW VARIABLES LIKE 'general%';
	set GLOBAL general_log='ON';
	general_log：日志功能是否开启，默认关闭OFF
	general_log_file：日志文件保存位置
  
7.慢日志分析工具用过的分析工具 
	pt-query-digest 慢日志分析工具
	参考文章：https://blog.csdn.net/seteor/article/details/24017913
8. 主从同步配置有哪几种，日志复制，事务复制，日志复制的步骤
9. 分表的规则，（hash，range二种形式）
10. innodb与myisam引擎的区别，索引的聚簇与非聚簇，行锁
11. 如何分析一条语句的性能？explain
type
	性能逐渐提高
	ALL 进行完整的表扫描,性能最差
	index 在索引树全扫描
	range 在索引树扫描，获取索引树的一部分，比如：uid有索引，下面语句使用range
	explain select * from uchome_space where uid in (1,2)
	ref 可以用于单表扫描或者连接,连接字段非索引
	eq_ref 可以用于单表扫描或者连接，唯一索引或者主键索引
	const where 后面的连接字段，主键或者唯一键
possible_keys：可能会使用的索引
keys：使用的索引
rows：MYSQL执行查询的行数，简单且重要，数值越大越不好
Extra：
	using index 只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的信息
	using where 未建立索引
	using temporary 需要创建一个临时表来容纳结果,典型情况如查询包含可以按不同情况列出列的GROUP BY和ORDER BY子句时。此时需要优化。
12. 对于mysql数据存储这块，自己有做过哪些事情，项目?

13. 数据库存储补充
操作系统按照8kB大小数据块为一个基本单位，一个数据块中存有数据库的几行数据其中有数据的行号。
对于聚餐索引，主键索引的叶子节点和非叶子节点是一个数据块，8KB大小。叶子节点（1个数据块）保存了几行数据
对于非聚簇索引，主键索引的叶子节点和非叶子节点是一个数据块，8KB大小。叶子节点（1个数据块）保存了几行数据的数据块地址和行号。
根据索引找数据，首先需要将通过一次io或多次io，将索引节点（数据块）读取到内存中，然后找到真正数据（非聚簇索引，还需要数据块地址和行号去找）
（聚餐索引，节点数据就保存着整行数据）

14. 乐观锁与悲观锁
乐观锁：
使用数据版本（Version）记录机制实现，即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。先查询，更新update，where条件增加一个version字段
update set where version=
悲观锁：（行锁）
悲观锁分二种：
共享锁：
	select * lock in share mode 获取锁，再操作
排他锁：
	select for update 获取锁，再更新
```

- redis
```
1. redis二种数据备份持久化的机制以及简述?
	rdb:每隔一段时间改变次数到达一定次数，落盘
	aof:写操作就去落盘
2. redis有主从复制机制，慢日志机制
3. key的过期策略？
3.1 主动定时删除
3.2 取key时，检查删除
3.3 key淘汰机制
redis针对内存满了，有哪几种处理机制？ 一般是移除设置过过期时间的key
	# volatile-lru -> 利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )
	# allkeys-lru -> 利用LRU算法移除任何key
	# volatile-random -> 移除设置过过期时间的随机key
	# allkeys->random -> remove a random key, any key 
	# volatile-ttl -> 移除即将过期的key(minor TTL)
	# noeviction -> 不移除任何可以，只是返回一个写错误
4. redis有哪几种数据结构？写出每种数据结构set命令
	string, set foo bar
	hash, hset foo age 24
	set, sadd foo bar
	sort set, zadd foo bar 1
	list, lset foo bar
5. 缓存和数据库双写问题（redis保证最终一致性）
5.1 为了没有脏数据，采用先写数据库后删除缓存，还可以使用 写数据库后使用队列进行补偿（binlog日志等方式）

6. 透和雪崩该如何处理？
- 被动缓存：
	1. 先更新数据库再删除redis，过期时间设置随机。
	2. 进来的第一个进程上锁，从数据库取数据。
- 主动缓存：
	1. 脚本主动从数据库取数据，更新缓存，保证缓存不失效。

7.dis集群并发竞争key的问题该如何处理？
	redis是单进程程序，多个set操作同时进来，由于操作顺序不一致出现数据不一致问题。
	解决方案：
		1. 分布式锁- redis-setnx
		2. 消息队列 - 并发操作变成并行操作
```

- git
```
0. 工作区，暂存区，本地分支

1. 如何取消一个文件的修改？
	git reset HEAD <file> // 抵消 add
	git checkout -- filename
2. 一个文件提交到版本库了，如何撤回？
	版本回退，git reset或者 git revert
3. 分支回滚命令git revert和git reset的区别？
	git revert 是对一次commit逆操作，分支继续往前进
	git reset 是分支后退，回退到某一个commit
4. git rebase作用
	merge过分支后，历史事件重新排序变成直线
	合并分支，将分支的所有commit提交汇集成一个commit
	git rebase -i --autosquash master
```

- mongo
```
1. 将select * from a where id > 1翻译成mongo语句?
	db.a.find({"id":{$gt:1}})
2. 为a集合的userid,ctime字段创建联合索引语句
	db.a.createIndex({"userid":-1,"ctime":-1})
3. 查看a集合有哪些索引
	db.a.getIndex();
4. 有没有mongo本身做过项目或者事情?
```

- vim,sed
```
1. 替换一个文件中的一段文字,有几种方式?
	vim %s/old/new/gc,sed命令
```

- tcp
```
1. tcp状态时序图
参考文章：https://blog.csdn.net/abc_ii/article/details/18603469
三次握手
	1. 客户端发送syn包，自身状态变成syn_sent
	2. 服务端收到syn包，返回syn+ack包,自身状态变为syn_revd
	3. 客户端接收到syn+ack,返回ack包，自身状态变为established
	4. 服务端收到ack包，自身状态变为established
四次挥手
	1. 客户端发送fin包，自身状态变为fin_wait_1
	2. 服务端收到fin包，返回fin+ack,自身状态变成closing
	3. 客户端接收到fin+ack，自身状态变成fin_wait_2
	3. 服务端自身关闭时，发送fin包,自身装填变成close_wait
	4. 客户端接收到fin包，返回fin+ack包,自身变成time_wait,等2msl变成closed
	5. 服务端接收到fin+ack包，自身变成closed
2. 在服务端抓取与某一个客户端来往的tcp,80包？
	tcpdump -X -s 0 -iany host xxx.xxx  -w '/tmp/tcp.cap' 在把tcp.wap用wireshark打开
3. tcp有哪些字段
3.1 来源端口
3.2 目标端口
3.3 序列好和确认序列号
3.4 包长度
3.5 tcp标志位，ack，fin，syn，rst
3.6 滑动窗口，流量控制
3.7 校验和
http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html
https://www.cnblogs.com/ellisonzhang/p/10402863.html - 推荐
4. 一个帧中数据包 最大1500字节 加上帧头 14字节，加上帧尾 4字节。标准只有576字节。
所以 UDP 单个包过大，会在ip层进行分包，会有丢失可能，UDP要控制数据应用在 1500 - 20（IP首部长度） - 8（UDP首部长度） 以下
最好控制在 576 - 20（IP首部长度） - 8（UDP首部长度） 以下
5. tcp 不需要控制 应用数据大小，因为tcp会进行流量控制，序列号。
tcp首部长度 20 ，所以一个数据长度 1500 - 20（IP首部长度） - 20（tcp首部长度）
6. 端口号最大值，为什么？
2的16次方，因为在tcp首部字段中只分配给了16个位用于存储端口号
7. wireshark抓包分析
7.1 可以 statistic -> flow graph 直观查看发送过程
7.2 wireshark fiter : 有三个主要实体 ip, tcp, http。分别对应ip首部，tcp首部，http首部字段。
比如 tcp.flags.syn == 1 && tcp.flags.ack == 1， ip.src == 192.168.200.231
7.3 tcp.stream eq 0 和 follow tcp stream
```

- ip层首部字段
```
1. version 版本号
2. header lenth 长度，20字节 tcp首部字段长度也是20字节，udp首部字段长度8个字节
3. fragment offset 分片偏移
4. proto 协议
5. checksum 奇偶校验
6. 源ip
7. 目标ip
```

- shell
```
pwd=/workspace
cd $pwd
for i in ` mysql -h xxx -uxxx -pxxx -e 'select * from xxx' | awk '{print $1}'  | awk -F '.flv' '{print $1}' | awk -F '/' '{print $2}'`
do	
	if [ ! -d $pwd$i ];then
		mkdir $pwd$i;
		cd $pwd$i;
		// do something
		rm -rf $i.flv;
	fi
done
```

- docker
```
Dockerfile：用来生成镜像
1. docekr build -t imageName .
镜像：好比是容器的存档
1. docekr images
2. docker rmi xxx
镜像运行变容器:
1. docker run -d --name --privileged -p -v --rm --link=mysql:mysql image_name
容器:
1. docker ps
2. docker container ls -a
3. docker rm
容器变镜像:
1. docekr commit con 
仓库:
1. docker pull centos:6
2. docker push
3. docker login
```

- php
```
1. 问一个解题思路？
2. linux下如何安装一个redis扩展，具体步骤？
3. 有没有做过php本身相关的项目，事情？php业务开发过程中遇到过的比较难问题？
```

- golang
```
0. 中级golang开发者知识点：https://gobyexample.com/
1. golang知识图谱 https://github.com/gocn/knowledge
2. GOROOT ，GOPATH, PATH
	GOROOT: go安装包根目录
	PATH = $GOROOT/bin
	GOPATH: go的工作目录 $gopath/src,$gopath/pkg,$gopath/bin
3. go执行过程
4. interface与反射
	reflect.TypeOf reflect.ValueOf,类型强转
5. 常用包
	文件读取 os.OpenFile
	时间日期 time.Time().Unix()
	json解析，
	字符串处理，正则处理，锁与sync包，网络处理，国际化
	
6. 进阶 
	GPM模型，内存布局，CGO，反射，内存管理，GC，go调度，channel调度,Go编译共享库so
7. 面试题
	1. https://blog.csdn.net/yuanqwe123/article/details/81737180
	2. https://blog.csdn.net/itcastcpp/article/details/80462619
	
8. 数组:
定义：var a1 [5]int, a1:= [...]int{}

9. slice：
定义: var s1 []string, s1 := []string{"foo","bar"}
增加k,v s1=append(s1, v)
删除i: s1 = append(s1[:i], s1[i+1:]...)
遍历slice：
for i,v := range s1 {

}
长度： len(s1)
容量：cap(s2)
问题1：slice如何增加一个元素，删除一个元素

10. map：
定义： m1 := make(map[string]string)
增加k,v m1["foo"] = bar
删除v delete(m1, "foo")
判断k存在 value, ok := m1["foo"]
遍历map: 
for k,v := range m1 {

}
问题1：如何判断键是否存在？

11. 包：
一个目录下只能有一个包名
目录名称可以和包名不同
不同的二个目录可以有相同的包名 - 非常不推荐

import 基于src目录，具体跟的是文件夹路径

12. go不用去关心分配在堆上还是栈上

13. go仅支持封装，不支持继承和多态

14. 可变参数的获取，通过range遍历参数

15. go get 和 go install 区别
	go get -x
	1. 下载代码 GOPATH/src/<input-package>
	2. 编译,生成.a
	3. 安装,生成.exe
	go install library
	1. 编译,生成.a
	2. 安装,生成.exe

16. GPM 模型怎么样的
17. 内存回收机制？如何监控结构体的内存空出来了？ 
	三色，引用计数，达到内存阈值，stop the world
18. 队列出现饥饿情况怎么办？
19. goroutine的调度机制，如果P一直抢占了M 怎么办？

1. make(chan struct{}) struct{}空结构体，长度为0，用于消息通知
3. 多个goroutine同时访问一个map, 会出现致命错误，fatal error。数据同步问题要加锁，锁颗粒要越小越好。
4. 如何分析死锁？
	使用debug.printStack()打印goroutine的堆栈信息，看goroutine运行时长
5. 如何分析资源竞争？
5. 闭包：匿名函数 + 数据 一起封装了
6、make(chan int) 与 make(chan int, 1) 区别，后者第一个goroutine不会阻塞
7、队列出现饥饿情况怎么办？
从其他p拿取goroutine和全局队列中拿取
8、goroutine的调度机制，如果P一直抢占了M 怎么办？
检测占用时间
```

- 算法
```
1. 二叉树的时间复杂度是多少 O(n*lgn)
2. 一千万条数据，找到top100的数据？排序。（快排和堆排序）
3. 10亿条数据中，查找一个存不存在数据。hash O（1），布隆过滤器
布隆过滤器：https://www.jianshu.com/p/2104d11ee0a2
通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。
4. 广度搜索 与 深度搜索 怎么弄？前序遍历 + 队列，中序遍历 + 栈
```
- 算法问题
```
旅行家问题：从起点城市到终点城市。
解法：
1. 要找到经过最少城市节点，使用图的广度搜索
树也是图的特殊一种情况。广度搜索使用队列数据结构。
2. 要找到最短时间或者最短路径到终点。是带权边的图
使用迪杰斯特拉算法。图的广度搜索同时，不断刷新从一个节点到另一个节点的权重。
2.1 不能有环
2.2 不能有负权边，有使用贝曼算法

集合覆盖问题：广播覆盖区域有重叠，找到最大覆盖面积的最少广播台。
教室排课问题：一个课堂最大利用率，每节课有时间段。贪婪算法：上一堂结束后，下一堂课才开始。
解法：
1. 最优解，要遍历所有情况，耗费时间最久。
2. 使用近似算法。贪婪算法是近似算法一种。
2.1 贪婪算法每次找局部的最优解。注意局部最优解不是全局最优解，所以是一种近似算法。

背包问题：4磅的背包装物体，求装的物体价值最大。
最长子串，最长公共子序列：二个字符串相似程度。
解法：
动态规划：问题进行分割。状态转移方程：上一个值 vs （当前物品价值 + 剩余空间能容纳的最大价值）
解动态规划问题的步骤：
1.找出状态转移方程
2.设计自顶而下的递归算法 （Top-down approach）
3.改写成自底而上的迭代算法（Bottom-up approach）
缺陷：
1. 物品要么拿要么不拿走
2. 物品不能是连续，如果连续可以使用贪婪算法。

推荐算法：根据已有的特征推荐给他类似的内容。将他进行分类，分组。
解法：
将他的特征抽离，根据距离公式，最近的k个人是在哪个分组，则把他分入改组。
```

- 职业生涯
```
1. 处于什么目的离职
```
