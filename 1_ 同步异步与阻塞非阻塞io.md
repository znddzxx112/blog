- 参考文章
```
https://segmentfault.com/a/1190000003063859#articleHeader11
http://rango.swoole.com/archives/508
```

- 用户空间与内核空间
```
现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。
```

- 进程切换
```
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

注：总而言之就是很耗资源，具体的可以参考这篇文章：进程切换
```

- 进程的阻塞
```
文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。
```

- 缓存 I/O
```
缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。

缓存 I/O 的缺点：
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。
```

- 何为一次完整的io？
```
数据从存储或者网络 存到用户态（进程内存空间）
```

- 何为阻塞和非阻塞?
```
进程是否被堵塞，被挂起，堵塞时候不占用cpu
```

- 同步io与异步io
```
数据在完成一次io操作(从存储到用户态)过程中，进程被阻塞，称为同步io
没有被阻塞,称为异步io
```

- io模式
```
刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：
1. 等待数据准备 (Waiting for the data to be ready)
2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)

正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。
- 阻塞 I/O（blocking IO）
- 非阻塞 I/O（nonblocking IO）
- I/O 多路复用（ IO multiplexing）
- 信号驱动 I/O（ signal driven IO）
- 异步 I/O（asynchronous IO）
```

- 内核操作数据梳理
```
kernel

文件描述符

内核态（缓冲区 page cache）

用户态 （进程分配的内存）
```

- 阻塞io模型流程
```
1.进程调用内核后阻塞
2.直到内核将数据放到用户态后
3. 才唤醒进程
```

- 非阻塞io模型流程
```
1. 进程调用内核后，内核立马返回状态，进程不阻塞
2. 进程询问内核态数据准备情况
3. 不断询问内核，直到内核态告诉，数据完成
4. 进程阻塞，内核将数据从内核态放到用户态
5. 唤醒进程
```

- io复用模型流程
```
1. 进程调用select/poll/epoll，进程阻塞
2. 内核将数据放到了内核态后，通知进程，进程被唤醒
3. 进程发指令给内核进行拷贝，再次阻塞
```

- 异步io
```
1. 进程调用内核后，不阻塞
2. 内核将数据放到用户态后通知进程
3. 进程再处理
期间不会询问内核
```

- 总结
```
io复用不会提高单个线程吞吐，但是能支持更多链接，提高整个程序吞吐
```
