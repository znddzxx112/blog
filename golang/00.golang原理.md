```
runtime包
1. 设置GC收集百分比
2. 设置P的数量 GOMAXPROC
3. 获取GOARCH、GOOS和GOROOT


1. 内存管理
2. 内存布局
3. go程调度 - GPM 模型
4. channel调度 - 缓冲与非缓冲，如何优雅关闭channel
https://blog.csdn.net/qq_33296108/article/details/82731686
N 个发送者 M个接收者，如何关闭？加一把锁
type MyChannel struct {
	C      chan T
	closed bool
	mutex  sync.Mutex
}
添加一个 停止通知 接收端告诉发送端不要发送了
5. 反射 valueOf，TypeOf， 断言，强转换
6. 启动顺序


```

### GPM模型

```
以前GM模型，从全局队列中获取G程时，频繁上锁，影响性能，所以加入了p(PROC 本地队列)。
多个P队列事先从Goblo队列获取G程，M绑定P队列时就可以执行P队列中的G程，竞争的情况少了许多。

M对应的是 内核线程KSE,一一对应，通过runtime.SetMaxThread设置
P对应的是 上下文，从全局队列获取Goroutine，拿到本地队列中。绑定了M，就开始执行其中的Goroutine。Goroutine如果有阻塞，就让GOroutine处于等待状态。可以通过runtime.MAXPROCESSNUM()
G对应的是 Gotoutine,通过go关键词生成，会划分GOroutine自己的堆栈和内存空间。同时有多个状态。

P与M是抢占式调度。


```

### map、slice

- https://ninokop.github.io/2017/10/24/go-hashmap/
- map
```
参考文章：https://i6448038.github.io/2018/08/26/map-secret/
主要有二个结构
hmap和bmap
bmap相当于bucket
hmap保存2^B个bucket
每一个bucket有8个CELL，每个cell就是一对key=>value

访问的过程：
key 使用aes散列函数或者memhash散列函数，生成一串hash值,hash值的后B位对应的十进制数就是bucket号
根据hash值的高8位对应一个bucket里某一个cell

冲突解决：
golang使用链表的方式，还有一种开放地址法，准备更多的空位

扩容过程：
当装载因子（有数据的位置/总位置）高了，就开始扩容更多位置。一倍一倍开始扩容。
新的hmap会指向旧的hmap，旧的hmap中的数据不会立马迁移到新的hmap中，当旧的hmap中数据被访问时，才会迁移到新的map
```

- slice
```
指针，长度len，容量cap
```


### channel



- https://ninokop.github.io/2017/11/07/go-channel/
- channel数据结构 
```
使用一个环形队列
保存发送者Goroutine队列
保存接受者Goroutine队列

```

- channel目的
```
接受：从一个goroutine中的内存数据拷贝到channel环形队列中
发送：从channel环形队列中拷贝到goroutine内存中
```

- 理解发送阻塞
```
当前goroutine被挂起，并且放到保存发送者Goroutine队列中。等环形队列被消费了，唤醒发送队列保存的goroutine
```

- 如何从channel获取数据
```
for-range
for-select

i,ok := <-ch
当ok为true说明获取到数据,当ok为false说明队列已经关闭

select实现
将每个case后面的管道，放到一起存放在队列中
随机对某一个case求值，如果能获取到数据则执行
否则执行default case，
否则阻塞

```

